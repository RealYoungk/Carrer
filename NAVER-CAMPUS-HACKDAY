# NAVER-CAMPUS-HACKDAY

# Sylas
EDA 기반의 실시간 동기화
## 미션
### Step1. MongoDB 설치
- DB 설치
- CRUD 테스트
### Step2. EDA 이해
- Asynchronous Non-blocking I/O Model
- WebFlux
### Step3. DATA 설계
- 길찾기 히스토리
- 즐겨찾기 타임스탬프
### Step4. API 설계/구현
- WebClient
- MongoClient
- Rest API
### Step5. 장애대응 설계 (선택)
- circuit breaker
- threshold
## 요구사항
- Java or Kotlin
- MongoDB
- 호기심
## 느낀점 및 결과
### 목표했던 결과 얻지 못함
- SpringBoot에 익숙치 않았음(어노테이션, 종속성, 프로잭트생성, 환경설정)
- 알수없는 몽고디비 에러 및 버그(내가 뭔가 잘못 했겠지만, 몽고디비 설정이 안되거나 알수없는 오류가 많았음)
- 익숙치 않은 Spring Boot 로 결과물을 내려고 이해 없이 소스코드를 보고 아웃풋을 내려고 해 에러에 대응못함
### 좋은 경험을 했다
- 데이터 스키마 작성
- 협업(git/설득)
- Spring Boot 진입장벽 낮춤
- MongoDB CURD to JAVA
- Study EVENT DRIVEN
### 자기성찰
- 실력적 부족함 많이 느낌
- Spring Boot 환경설정에서 시간을 많이 보냈을때 의지가 많이 꺾임
- 스프링 공부 하자

## OUTPUT

### 이벤트 드리븐

**전통적인 방식**

- CPU	->	I/O
- CPU	<-	I/O

 **이벤트 드리븐 방식**

CPU	

           ->	CONTROLLER	->	I/O
	        <-	CONTROLLER	<-	I/O

	        ->	CONTROLLER	->	I/O
	        <-	CONTROLLER	<-	I/O

        	->	CONTROLLER	->	I/O
	        <-	CONTROLLER	<-	I/O

        	->	CONTROLLER	->	I/O
        	<-	CONTROLLER	<-	I/O

- I/O연산이 끝날때까지 CPU가 BLOCK되는 전통적인 방식과 달리
CPU는 CONTROLLER를 통해 입출력이 끝남을 통보받는다.

### 새롭게 알게 된 내용
**BLOCKING**
- 서버소켓의 accept가 병목
- 여러 클라이언트가 동시 요청시 블로킹 발생
- 클라이언트 수 증가-> 서버 스레드 수 증가
- 서비스 불가 상황을 피하기 위해 스레드 풀링 사용
(*스레드 풀링 : 스레드 할당/수거시의 오버헤드를 줄이기 위해 미리 스레드 풀장을 만듬)
- 최대 동접 사용자수는 스레드 풀링 값에 의존됨

### 생각해봐야할 포인트
**자바의 가비지 컬렉션 관점★**
- 풀링 스레드를 다 쓰고 추가적인 스레드를 할당할때 자바의 GC때문에 언급하신것 같다.

**컨텍스트 스위칭관점**
(*컨텍스트 스위칭 : 실행중인 스레드가 있지만 우선순위가 높은 스레드의 인터럽트를 받아서 실행할때)


### NON-BLOCKING
- 셀렉터 스레드 하나가 모든 클라이언트에 대응된다.
- 스레드 하나로 클라이언트에 대응되는데 왜 스레드 하나를 쓰는게 아니라 여러개를 사용할까라는 궁금증 생김
- 셀렉을 하는 스레드는 하나지만 뒤에서 I/O작업을 처리하는 스레드는 여러개임
- 서버/클라이언트 동작을 이벤트로 변환한다(당연함)


### 이벤트 루프
- 이벤트를 실행하기 위한 무한루프 스레드
- 큐에 이벤트를 넣고 이벤트가 있을때 꺼내서 실행
- 단일스레드루프, 다중스레드 루프로 나뉨(이벤트 루프가 지원하는 스레드 종류에 따라)


### 네티 이벤트 루프
- 네티의 이벤트는 채널에서 발생
- 이벤트 루프 객체는 이벤트 큐를 가진다
- 네티의 채널은 하나의 이벤트 루프에 등록
- 네티는 리엑터 퓨처를 지원한다

### 채널 파이프라인
- 채널 파이프라인은 채널에서 발생한 이벤트가 이동하는 통로
- 이 통로를 통해서 이동하는 이벤트를 처리하는 클래스를 이벤트 핸들러라고 하면 이벤트 핸들러를 상속받아 구현한 구현체를 코덱이라고 함

### 서벌릿 VS 네티

- 백엔드 없이 동작->주목할만한 차이 없음(TPS/SUCESS/FAIL)
- 백엔드 없이 동작이라는게 내부 I/O처리 라고 이해를 했다.
- 내부I/O의 대표적인 예로 메모리 접근..이있지않나 싶다

- 네티가 시피유 사용률이 높은건 사실이나 백엔드 즉시 리턴 시 TPS/SUCESS/FAIL은 좋다
- 백엔드 즉시 리턴은 외부 I/O로 이해 했으며 디스크 접근인것 같다

- 네티의 시피유 코어에서 이벤트루프 8개이상은 TPS의 유의미한 차이가 없어 의미가 없다

- netty를 도커라이징 하면 성능 20%감소





### ★webflux 결론★
- 고정쓰레드 사용으로 적은 메모리로 확장 가능
풀링방식도 고정쓰레드 사용한다고 이해 하였는데 (필요하다면 추가로 더 할당)풀링과 webflux의 차이는 이벤트 드리븐이고 이 이벤트 드리븐이 적은 메모리로 확장 가능의 차이를 만드는게 아닌가 싶음

- 리액티브 및 논블로킹이 일반적으로 애플리케이션을 더 빠르게 실행하지는 않는다. I/O가 적은경우 더 빠름

- 적은수의 고정쓰레드를 사용한다

- 추가쓰레드가 필요없다
풀링과의 차이점인듯

- 시피유 코어수에 이벤트 워커수를 사용 톰캣(서블릿)보다 적합한 분야가 있다. 분야가 다르다



### 논블로킹의 오해
- 나만 논블로킹이면 의미없음, 큐방식이여서 견고하다
- 스레드 경합은 피해야한다(모니터링,메트릭,격리,설정공유 제외)
- 컨텍스트 스위칭이 아주아주아주 적게발생
- 공통적인 잡을 모든 쓰레드가 하면 성능 저하가 일어남 따라서 노멀한 비지니스만 수행













### 네이버 캠퍼스 핵데이 후기

- 네이버에서 많은 감정을 느꼈지만, 아쉬움이 가장 컸습니다.
쉬운 주제임에도 아웃풋을 내지 못한 게 아쉽네요. 아웃풋을 내지 못한 이유를 돌이켜보면 과한 욕심을 냈었습니다. 살면서 처음으로 스프링 부트라는 프레임워크를 접해보고, 어노테이션도 잘 모르고, 의존성, 툴 쓰는 법 등 모든 것이 두렵고 낯설었습니다. 하나
하나 극복해 나가는 부분도 분명히 있었지만 JAVA 기본기가 많이 약해서 어떻게든 책이나 구글링을 통해 소스를 벤치마킹해서 내가 원하는 결과물을 내야겠다는 생각이 강했고 에러 문제를 해결하지 못해서 위와 같은 결과에 도달한 것 같습니다.

- 하지만 유익했던 시간이었습니다.
먼저 실력을 직시하는 자리였습니다. 결과는 냉정했지만 이번 핵데이를 발판 삼아서 더 열심히 해보려고 합니다.
공부를 어떻게 해야 할지 많은 깨달음을 얻었습니다. 내 생각 선택 이유 등을 정리하고 기록을 남기고 공부의 깊이를 높이려고 합니다.
학교를 다니며 생긴 많은 궁금증들을 해결하고 확인할 수 있었습니다.
면접을 당하는 것 같은? 적당한 긴장감을 느낄 수 있어서 좋았습니다.
깃을 어떤 방식으로 사용하는지 처음 알게 되어서 좋았습니다.

- 좋은 프로그램 만들어주신 네이버 관계자 모든 분께 감사드리며
네이버가 원하는 사람은 전혀 아니었지만 가까운 미래에 그런 사람이 되어서 나타나고 싶네요
많이 배우고 느끼고 즐기는 행복한 1박 2일이였습니다.

- 우리 12조 태수, 진흥이 열심히 하는 모습 보기 좋았고 성공했으면 좋겠다.
이형규 멘토님 좋은 피드백, 조언 감사합니다. 풀리지 않은 고민들이 풀려 좋았습니다.

다들 수고하셨습니다!!!!!!!!!!!!!!







